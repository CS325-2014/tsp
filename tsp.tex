\documentclass[12pt,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage{anysize}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{algpseudocode}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

\newcommand{\contradiction}{%
\begin{tikzpicture}[rotate=45,x=0.5ex,y=0.5ex]
\draw[line width=.2ex] (0,2) -- (3,2) (0,1) -- (3,1) (1,3) -- (1,0) (2,3) -- (2,0);
\end{tikzpicture}
}

\marginsize{2cm}{2cm}{1cm}{1cm}

\begin{document}

\begin{titlepage}
    \vspace*{4cm}
    {\huge \center
        CS 325 Traveling Salesman Report\\[1cm]
    }
    \center
    {\large
        Group 3

        Date: \today

    \textbf{Contributors:}
    Cezary Wojcik,
    Sean McGlothlin,
    Matthew Eilertson
    }

\end{titlepage}

\section*{Introduction}

The Travelling Salesman Problem (TSP) is a classic problem that asks: Given a set of cities and distances between those cities, find the shortest possible loop that visits every city. The TSP is an NP-Hard problem that has a brute force running time of $O(n!)$, which is obviously unacceptable for us. Instead of finding an optimal solution, we will be finding "good" solutions that are found much quicker.

Our TSP algorithm finds close to optimal solutions through a combination of random permutations, divide and conquer, and (random swaps). The cities are divided into groups based on grid proximity and then random solutions are generated in each isolated grid. Once the best solutions are found, they are joined with random permutations. Lastly, the solution is improved through random swaps that are committed if the distance is shortened, but discarded if not.



\section*{Random Permutations}

A core part of our algorithm for the TSP is to simply create a random order of cities to be visited. While random luck is rarely a good idea, we can reduce the likelihood of bad solutions by running lots of random solutions and selecting the one that has the shortest path. In this implementation, each newly randomized path is compared to the minimum path discovered so far, if it is shorter then the new path becomes the minimum path and the old one is discarded. This method is more effective on smaller sets of cities since there are fewer permutations of cities. Larger sets have much more permutations, so the odds of finding suboptimal paths are much higher.

This idea was inspired by Group 18's approach using random neighbor inclusion. In their approach, they took a small set of close cities, connected them, and then added random cities to the loop until all the cities are included. They would then run this algorithm multiple times and keep the shortest path found. We decided to change their idea by removing the requirement of finding a close set of cities first, which could be slow. Instead, we create many more permutations of cities and keep track of the best path.

\section*{Divide and Conquer}

One of the major difficulties of the TSP, is that optimal solution algorithms quickly become infeasible as the number of cities increase. Our algorithm is not optimal, but it can still be slowed down by sufficiently large sets of cities. By applying a divide and conquer method to the TSP, we can process larger sets of cities faster.

As the algorithm reads in the cities of the TSP, we create an initial grid of 5x5 to separate the cities into smaller groups. However, the cities may be densely grouped, so if any individual block contains more than a specific amount $Threshold$, then we divide that block into another 5x5 grid. We continue this until we have a number of subproblems that are no larger than $Threshold$.

By reducing the size of the problem into many small subproblems, even inefficient algorithms become faster as the sets are smaller. 

\section*{Divide and Conquer With Randomized Assembly}

Once our algorithm has divided the problem into a number of smaller subproblems, the randomized path trials begin in each block. We will calculate $n^3$ random paths, where n is the number of cities in a given grid block. Next, we take the minimum path found and return that path to be connected to the other shortest paths found in the other blocks. Once all of the shortest paths have been found, randomized path trials are again used to connect the blocks to other blocks by treating the subpaths as individual cities, and then those are in turn connected to even larger blocks until all the cities are connected in a tour.

\section*{Shortest Path Improvability}
It is worth mentioning that we wrote our code in a way such that our "pathfinder" function can be replaced with any function that can determine the shortest path of a graph, and the code will run the same way, and quite possibly faster. That being said, it would be incredibly simple to find some MST library or shortest path implementation (such as Bor\r{u}vka's Algorithm, as we discussed in our presentation) and use that in place of the pathfinder function we wrote.

\newpage

\end{document}
