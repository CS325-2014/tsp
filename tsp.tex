\documentclass[12pt,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage{anysize}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{algpseudocode}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

\newcommand{\contradiction}{%
\begin{tikzpicture}[rotate=45,x=0.5ex,y=0.5ex]
\draw[line width=.2ex] (0,2) -- (3,2) (0,1) -- (3,1) (1,3) -- (1,0) (2,3) -- (2,0);
\end{tikzpicture}
}

\marginsize{2cm}{2cm}{1cm}{1cm}

\begin{document}

\begin{titlepage}
    \vspace*{4cm}
    {\huge \center
        CS 325 Traveling Salesman Report\\[1cm]
    }
    \center
    {\large
        Group 3

        Date: \today

    \textbf{Contributors:}
    Cezary Wojcik,
    Sean McGlothlin,
    Matthew Eilertson
    }

\end{titlepage}

\section*{Introduction}

The Travelling Salesman Problem (TSP) is a classic problem that asks: Given a set of cities and distances between those cities, find the shortest possible loop that visits every city. The TSP is an NP-Hard problem that has a brute force running time of $O(n!)$, which is obviously unacceptable for us. Instead of finding an optimal solution, we will be finding "good" solutions that are found much quicker.

Our TSP algorithm finds close to optimal solutions through a combination of random permutations, divide and conquer, and (random swaps). The cities are divided into groups based on grid proximity and then random solutions are generated in each isolated grid. Once the best solutions are found, they are joined with random permutations. Lastly, the solution is improved through random swaps that are committed if the distance is shortened, but discarded if not.



\section*{Random Permutations}

A core part of our algorithm for the TSP is to simply create a random order of cities to be visited. While random luck is rarely a good idea, we can reduce the likelyhood of bad solutions by running lots of random solutions and selecting the one that has the shortest path. 


\section*{Divide and Conquer}

One of the major difficulties of the TSP, is that optimal solution algorithms quickly become infeasible as the number of cities increase. Our algorithm is not optimal, but it can still be slowed down by sufficiently large sets of cities. By applying a divide and conquer method to the TSP, we can process larger sets of cities faster.

As the algorithm reads in the cities of the TSP, we create an initial grid of 5x5 to separate the cities into smaller groups. However, the cities may be densely grouped, so if any individual block contains more than a specific amount $Threshold$, then we divide that block into another 5x5 grid. We continue this until we have a number of subproblems that are no larger than $Threshold$. 

\section*{Random Swap Improvements}
Our algorithm uses smart randomization by taking each subdivided block and running random comparisons on them to attempt to find a short path. Of course, this won't find the optimum path, but it will get us close in most cases, and we may even get lucky once in awhile. We calculate $n^3$ random paths, where n is the number of cities in a given grid block. Next, we take the minimum value returned by that calculation and return that path to be connected to other short paths. From there, we can connect larger blocks to each other using the same method which treats each connected block as an individual city. This is repeated until all cities are connected.

\textsc{HValue}(H, i, j):
\begin{algorithmic}
\If {i < 0 or j <    0}
    \State \Return 0
\Else
    \State \Return H[i][j]
\EndIf
\end{algorithmic}

\textsc{Heuristic}(grid, i, j):
\begin{algorithmic}
\State $H \gets$ Array2D()
\For{y = 0 to j}
    \For{x = 0 to i}
        \State H[x][y] $\gets$ grid[x][y] + $\max \{$ \textsc{HValue}(H, i-1, j), \textsc{HValue}(H, i, j-1), 0  $\}$
    \EndFor
\EndFor
\State \Return H
\end{algorithmic}

\newpage

\end{document}
